// ****************************************************************************
//
//          Aevol - An in silico experimental evolution platform
//
// ****************************************************************************
// 
// Copyright: See the AUTHORS file provided with the package or <www.aevol.fr>
// Web: http://www.aevol.fr/
// E-mail: See <http://www.aevol.fr/contact/>
// Original Authors : Guillaume Beslon, Carole Knibbe, David Parsons
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 2 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
// 
//*****************************************************************************




// ============================================================================
//                                   Includes
// ============================================================================
#include "individual_factory.h"


namespace aevol {


//##############################################################################
//                                                                             #
//                           Class IndividualFactory                           #
//                                                                             #
//##############################################################################

// ============================================================================
//                       Definition of static attributes
// ============================================================================

// ============================================================================
//                                Constructors
// ============================================================================

// ============================================================================
//                                 Destructor
// ============================================================================

// ============================================================================
//                                   Methods
// ============================================================================

/*!
  \brief Create an individual with random sequences

  \param exp_m global exp_manager
  \param param_mut mutation parameter of the newly created individual
  \param id index of newly created individual in the population
  \return clone of dolly
*/
ae_individual* IndividualFactory::create_random_individual(
    ae_exp_manager* exp_m,
    int32_t id,
    std::shared_ptr<ae_params_mut> param_mut,
    std::shared_ptr<ae_jumping_mt> mut_prng,
    std::shared_ptr<ae_jumping_mt> stoch_prng,
    const Habitat& habitat,
    double w_max,
    int32_t min_genome_length,
    int32_t max_genome_length,
    int32_t chromosome_initial_length,
    bool allow_plasmids,
    bool plasmid_initial_gene,
    int32_t plasmid_initial_length,
    char* strain_name,
    std::shared_ptr<ae_jumping_mt> local_prng)
{
  // ------------------------------------------------------- Global constraints
  // Create an individual and set its id
  ae_individual* indiv = new ae_individual(exp_m,
                                           mut_prng,
                                           stoch_prng,
                                           param_mut,
                                           w_max,
                                           min_genome_length,
                                           max_genome_length,
                                           allow_plasmids,
                                           id,
                                           strain_name,
                                           0);

  indiv->add_GU(indiv, chromosome_initial_length, local_prng);
  const GeneticUnit * chrom = &indiv->get_genetic_unit_list_std().back();

  if (allow_plasmids) // We create a plasmid
  {
    if (plasmid_initial_gene) // Then the plasmid is generated independently from the chromosome
      // indiv->add_GU(ae_genetic_unit(indiv, _plasmid_initial_length, _prng)); // a random sequence is generated by the ae_string constructor
      indiv->add_GU(indiv, plasmid_initial_length, local_prng); // a random sequence is generated by the ae_string constructor
    else // The plasmid has the same genome as the chromosome
    {
      char* plasmid_genome = new char [chromosome_initial_length + 1]; // As ae_dna constructor do not allocate memory but directly use the provided string, we allocate the memory here.
      strncpy(plasmid_genome, chrom->get_sequence(), chromosome_initial_length + 1);
      indiv->add_GU(plasmid_genome, chromosome_initial_length);
    }
  }


  // Insert a few IS in the sequence
  /*if (ae_common::init_params->get_init_method() & WITH_INS_SEQ)
  {
    // Create a random sequence
    int32_t seq_len = 50;
    char* ins_seq = new char[seq_len+1];
    int16_t nb_insert = 50;
    int16_t nb_invert = 50;

    for (int32_t i = 0 ; i < seq_len ; i++)
    {
      ins_seq[i] = '0' + ae_common::sim->prng->random(NB_BASE);
    }
    ins_seq[seq_len] = '\0';


    // Insert the sequence at random positions
    ae_mutation* mut1 = NULL;
    for (int16_t i = 0 ; i < nb_insert ; i++)
    {
      mut1 = indiv->get_genetic_unit(0)->get_dna()->do_insertion(ins_seq, seq_len);
      delete mut1;
    }


    // Invert the sequence and insert it at random positions
    char* inverted_seq = new char[seq_len+1];
    for (int32_t i = 0 ; i < seq_len ; i++)
    {
      inverted_seq[i] = (ins_seq[seq_len-1-i] == '1') ? '0' : '1';
    }
    inverted_seq[seq_len] = '\0';

    for (int16_t i = 0 ; i < nb_invert ; i++)
    {
      mut1 = indiv->get_genetic_unit(0)->get_dna()->do_insertion(inverted_seq, seq_len);
      delete mut1;
    }

    delete [] ins_seq;
    delete [] inverted_seq;
  }*/

  // Evaluate the newly created individual
  indiv->EvaluateInContext(habitat);

  return indiv;
}

/*!
  \brief Create an individual with random sequences. The individual have to have at least one good functional gene

  \param exp_m global exp_manager
  \param param_mut mutation parameter of the newly created individual
  \param id index of newly created individual in the population
  \return clone of dolly
*/
ae_individual* IndividualFactory::create_random_individual_with_good_gene(
    ae_exp_manager* exp_m,
    int32_t id,
    std::shared_ptr<ae_params_mut> param_mut,
    std::shared_ptr<ae_jumping_mt> mut_prng,
    std::shared_ptr<ae_jumping_mt> stoch_prng,
    const Habitat& habitat,
    double w_max,
    int32_t min_genome_length,
    int32_t max_genome_length,
    int32_t chromosome_initial_length,
    bool allow_plasmids,
    bool plasmid_initial_gene,
    int32_t plasmid_initial_length,
    char* strain_name,
    std::shared_ptr<ae_jumping_mt> local_prng)
{
  // First find a chromosome with at least one beneficial metabolic gene
  double env_metabolic_area = habitat.phenotypic_target().area_by_feature(METABOLISM);
  ae_individual* indiv = new ae_individual(exp_m,
                                           mut_prng,
                                           stoch_prng,
                                           param_mut,
                                           w_max,
                                           min_genome_length,
                                           max_genome_length,
                                           allow_plasmids,
                                           id,
                                           strain_name,
                                           0);
  indiv->add_GU(indiv, chromosome_initial_length, local_prng); // a random sequence is generated by the ae_string constructor
  const GeneticUnit * chrom = &indiv->get_genetic_unit_list_std().back();
  indiv->EvaluateInContext(habitat);

  while (indiv->get_dist_to_target_by_feature(METABOLISM) >= env_metabolic_area)
  {
    indiv->remove_GU(0);
    // chrom = new ae_genetic_unit(indiv, _chromosome_initial_length, _prng); // a random sequence is generated by the ae_string constructor
    indiv->add_GU(indiv, chromosome_initial_length, local_prng); // a random sequence is generated by the ae_string constructor
    indiv->EvaluateInContext(habitat);
  }


  // Then, if a plasmid should be created, make sure there is also at least one metabolic gene on the plasmid
  if (allow_plasmids)
  {
    if (plasmid_initial_gene == 1)
    {
      indiv->add_GU(indiv, plasmid_initial_length, local_prng); // a random sequence is generated by the ae_string constructor
      indiv->EvaluateInContext(habitat);

      while (indiv->get_genetic_unit(1).get_dist_to_target_by_feature(METABOLISM) >= env_metabolic_area)
      {
        indiv->remove_GU(1);
        indiv->add_GU(indiv, plasmid_initial_length, local_prng); // a random sequence is generated by the ae_string constructor
        indiv->EvaluateInContext(habitat);
      }
    }
    else
    {
      // The plasmid is a copy of the chromosome
      char * plasmid_genome = new char [chromosome_initial_length + 1]; // As ae_dna constructor do not allocate memory but directly use the provided string, we allocate the memory here.
      strncpy(plasmid_genome, chrom->get_sequence(), chromosome_initial_length+1);
      indiv->add_GU(plasmid_genome, chromosome_initial_length);
      indiv->EvaluateInContext(habitat);
    }
  }

  // Compute the "good" individual's statistics
  indiv->compute_statistical_data();

  // printf("metabolic error of the generated individual : %f (%" PRId32 " gene(s))\n",
  //         indiv->get_dist_to_target_by_feature(METABOLISM), indiv->get_protein_list()->get_nb_elts());

  return indiv;
}

// ============================================================================
//                            Non inline accessors
// ============================================================================
} // namespace aevol
